PHILOSOPHY OF THE PROJECT:
Project DUNE is a playable workbench used to learn, test and stress some sophisticated computer graphics algorithms such as Marching Cubes or artificial life programs like Boids.
The objective was meshing up all of this amazing techniques inside a single experience.

********************************************************************************
CONTROLS:
To move the spaceship use the letters W (forward) A (left) S (backward) D (right);
Use the mouse to rotate the camera;

SPECIAL CONTROLS:
Q - Move down the spaceship;
E - Move up the spaceship;
R - Reset to the initial position;
M - Go back to the main menu;

********************************************************************************
LIST OF GENERATED OBJECTS:
-Mountains and terrain: The construction of the mountains and the terrain are strictly correlated. Both of them exploit the Marching Cubes techniques.
	To begin with, some points are setted on the scene using the Poisson disk sampling at variable radius, variable density (https://en.wikipedia.org/wiki/Supersampling#Poisson_disk).
	Only the points over a given threshold will be used to generate the map.
	Starting from this results, a SDF Cylinder function is used to compute the distance between each point (https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm).
	Subsequently a different layers, with different frequency and intensity, of 3D Perlin noise are applied over the initial data.
	Then in order to build the terrain a SDF is computed over the bitmap "voronoiNoise" (/Assets/RocksGenerators).
	Eventually the two SDF are combined (https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm - Union primitive).
	In the end we will obtain a low resolution mesh used to manage the collisions, an high resolution mesh used as a model for the environment and a 3D texture that will be used
	to manage the boids behaviour.
	The colour of the mountains and the terrain is realized using the information stored inside the vertex colour of the mesh, this values are computed using a naive ambient 
	occlusion algorithm.
	The marching cubes technique allowed us to retrive vertexes and triangles from a 3D array (https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-1-generating-complex-procedural-terrains-using-gpu)
	This entire procedure can be tested and tweaked using the scene "Rock_WorkBench";
	Some screenshot of this middle steps are added in the project archive.


-Boids: The mesh used for the boids is generated procedurally using the script "ConeGenerator".
	The behaviour of the Boids is the one described inside the Craig Reynolds work (https://en.wikipedia.org/wiki/Boids).
	All the computations regarding the boids are executed through the GPU in parallel, and we do not generate an object for each boid, instead we exploit the DrawMeshInstancedProcedural (https://docs.unity3d.com/ScriptReference/Graphics.DrawMeshInstanced.html)
	method, in order to avoid the unnecessary overhead generated by creating multiple game objects.
	Initially we initialize the position of every object storing this values inside a buffer. At each frame the distance between each boid and the ambient is retrived from the previously generated SDF.
	In order to do this at each frame and for each object a spatial hashing (https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/spatial-hashing-r2697/) is computed 
	as to know the exact position in space of each boid. As I said before we also exploit the previously generated 3D texture to manage the collision between the boids and the ambient.
	Also the boids interact with the player avoiding him when he enters in certain radius from them.

********************************************************************************
REMARKS:
Some already known limitations of this project are represented by the number of Boids on screen. In the final build there are 2^11 boids on screen, using more than this
will likely slow down the performance of the application, this is due to the heavy number of computation the machine has to perform (distances, shader, colliders). A possible 
future improvement could be the tweak of the function which computes the distances between each boid and the ambient.

Another already known bug concers the collision between the player and the environment. In the final build I have used a sphere collider and exploited the physics that Unity offers,
obviously a better collider will already be a major improvement, but also a physics written ad hoc for this application would be even better. It can happens that the rigidbody of the 
spaceship could sometimes cause some bugs with the controls. Another possible improve could be a more sophisticated player controller.


********************************************************************************
EXTERNAL ASSETS:
Spaceship - https://www.turbosquid.com/3d-models/3d-drone-dron-model-1688993 - FREE
Script to generate the 3D Perlin noise - https://github.com/keijiro/NoiseShader - FREE
Script to perform a GPU based merge sort - https://github.com/nobnak/GPUMergeSortForUnity - FREE
Cinemachine - https://unity.com/unity/features/editor/art-and-design/cinemachine - FREE
Other small pieces of code were provided from forums or articles, in this cases a comment with the link of the resource is written in the code.